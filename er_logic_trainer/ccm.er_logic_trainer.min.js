(()=>{const component={name:"er_logic_trainer",ccm:"https://ccmjs.github.io/ccm/versions/ccm-26.4.0.js",config:{css:["ccm.load",["https://ccmjs.github.io/akless-components/libs/bootstrap-4/css/bootstrap.min.css","https://ccmjs.github.io/eild/er_logic_trainer/resources/styles.css"]],default:{format:"svg",images:["e","1","c","n","cn","r"],left:"copied",notation:"abrial",path:"https://ccmjs.github.io/eild/er_logic_trainer/resources/img/"},helper:["ccm.load","https://ccmjs.github.io/akless-components/modules/versions/helper-7.1.0.mjs"],html:["ccm.load","https://ccmjs.github.io/eild/er_logic_trainer/resources/templates.mjs"],feedback:true,legend:true,modal:{attr:["ccm.start","https://ccmjs.github.io/tkless-components/modal/versions/ccm.modal-3.0.0.js",{backdrop_close:true,content:"",closed:true,breakpoints:false,buttons:[{html:"<button class='btn btn-secondary' data-close>Abbrechen</button>"},{html:"<input type='submit' class='btn btn-primary' form='attr-form' value='Hinzufügen'>"}]}],legend:["ccm.start","https://ccmjs.github.io/tkless-components/modal/versions/ccm.modal-3.0.0.js",{backdrop_close:true,content:"",closed:true,buttons:""}]},notations:{abrial:{key:"abrial",title:"Abrial",swap:true,centered:true,comment:"Die Abrial bzw. (min,max)-Notation gibt für jeden an einer Beziehung beteiligten Entitätstyp an, mit wie vielen Entitäten auf der anderen Seite eine Entität dieses Typs mindestens und höchstens in Beziehung steht."},arrow:{key:"arrow",title:"Pfeilnotation",left:"mirrored"},chen:{key:"chen",title:"Chen",centered:true,comment:"In der Chen-Notation kann zur Spezifikation der Kardinalitäten jeder Entitätstyp entweder mit einer Kardinalität 1 oder mit einer Kardinalität N am Beziehungstyp partizipieren. (In dieser Grundform werden die Beziehungsmengen nur mit ihrer Maximalaussage genannt.)"},crow:{key:"crow",title:"Krähenfuß",left:"mirrored"},mc:{key:"mc",title:"MC"},uml:{key:"uml",title:"UML"}},onfinish:{restart:true},phrases:[{text:"Ein Fahrzeug kann einen Anhänger haben.",relationship:["Fahrzeug","hat","Anhänger"],solution:["c","c"],hints:[`Es handelt sich um eine 1:1-Beziehung, daher wird keine "hat"-Tabelle benötigt.\n             Da "Fahrzeug" und "Anhänger" über exakt identische Kardinalitäten verfügen, wird der Fremdschlüssel bei der Hauptentität "Fahrzeug" hinzugefügt.\n             Die Hauptentität (hier immer auf der linken Seite) ist die Entität, auf die in der zukünftigen Anwendung in der Regel zuerst zugegriffen wird.\n             Da ein Fahrzeug auch keinen Anhänger haben kann, muss der Fremdschlüssel optional sein.\n             Da der Fremdschlüssel auf "Anhänger" verweist, geht der Pfeil von "Fahrzeug" nach "Anhänger".`,`Normalerweise muss bei einer 1:1-Beziehung der Fremdschlüssel ein Alternativschlüssel sein, dies geht aber nicht, da dieser bereits optional ist.\n             Wegen der Eindeutigkeit kann ein Fremdschlüssel nicht gleichzeitig ein Alternativschlüssel und optional sein.\n             Dadurch kann es aber vorkommen, dass es mehrere Fahrzeuge gibt, die auf den gleichen Anhänger verweisen und somit ein Anhänger mehrere Fahrzeuge hat.\n             Dies lässt sich im relationalen Schema nicht besser darstellen und muss später in der Datenbank mit anderen Mitteln sichergestellt werden.`]},{text:"Zu jedem Topf gibt es einen Deckel, es gibt allerdings auch Töpfe ohne Deckel (z.B. Wok).",relationship:["Topf","hat","Deckel"],solution:["1","c"],hints:[`Es handelt sich um eine 1:1-Beziehung, daher wird keine "hat"-Tabelle benötigt.\n             Da "Topf" und "Deckel" über unterschiedliche Kardinalitäten verfügen, wird der Fremdschlüssel bei der schwächeren Entität "Deckel" hinzugefügt.\n             Eine Entität ist eine schwache Entität, wenn ihre Existenz von der jeweils anderen Entität abhängt.\n             Hier kann der Deckel nicht ohne Topf existieren, der Topf aber ohne Deckel.\n             Bei einer 1:1-Beziehung muss der Fremdschlüssel ein Alternativschlüssel sein, damit nicht mehrere Deckel auf den gleichen Topf verweisen können.\n             Da der Fremdschlüssel auf "Topf" verweist, geht der Pfeil von "Deckel" nach "Topf".`,""]},{text:"Zu jedem Patienten gibt es eine Patientenakte.",relationship:["Patient","hat","Patientenakte"],solution:["1","1"],hints:[`Es handelt sich um eine 1:1-Beziehung, daher wird keine "hat"-Tabelle benötigt.\n             Da "Patient" und "Patientenakte" über exakt identische Kardinalitäten verfügen, wird der Fremdschlüssel bei der Hauptentität "Patient" hinzugefügt.\n             Die Hauptentität (hier immer auf der linken Seite) ist die Entität, auf die in der zukünftigen Anwendung in der Regel zuerst zugegriffen wird.\n             Bei einer 1:1-Beziehung muss der Fremdschlüssel ein Alternativschlüssel sein, damit nicht mehrere Patienten auf die gleiche Patientenakte verweisen können.\n             Da der Fremdschlüssel auf "Patientenakte" verweist, geht der Pfeil von "Patient" nach "Patientenakte".`,`In der Praxis werden 1:1-Beziehungen häufig zu einer Tabelle zusammengefasst.\n             Es kann vorkommen, dass es eine Patientenakte gibt, zu der kein Patient existiert, der auf die Patientenakte verweist.\n             Das es zu jeder Patientenakte immer genau einen Patienten gibt, lässt sich hier im relationalen Schema nicht darstellen.\n             Dies muss später in der Datenbank mit anderen Mitteln sichergestellt werden.`]},{text:"Ein Rucksack kann mehrere Gegenstände enthalten.",relationship:["Rucksack","enthält","Gegenstand"],solution:["c","cn"],hints:[`Es handelt sich um eine 1:N-Beziehung, daher wird keine "enthält"-Tabelle benötigt.\n             Bei einer 1:N-Beziehung wird der Fremdschlüssel bei der einfachen Entität, also hier bei "Gegenstand", hinzugefügt.\n             Eine einfache Entität ist die Entität, die höchstens einmal mit der jeweils anderen Entität verbunden ist.\n             In diesem Fall kann ein Gegenstand immer nur in einem Rucksack enthalten sein.\n             Da ein Gegenstand sich auch in keinem Rucksack befinden kann, muss der Fremdschlüssel optional sein.\n             Da der Fremdschlüssel auf "Rucksack" verweist, geht der Pfeil von "Gegenstand" nach "Rucksack".`,`Die Lösung ist korrekt, sofern es darum geht den aktuellen Zustand eines Rucksacks festzuhalten.\n             Die Historie, was für Gegenstände ein Rucksack jemals enthalten hat, könnte man so aber nicht ermitteln.`]},{text:"Ein Wald hat Bäume.",relationship:["Wald","hat","Baum"],solution:["c","n"],hints:[`Es handelt sich um eine 1:N-Beziehung, daher wird keine "hat"-Tabelle benötigt.\n             Bei einer 1:N-Beziehung wird der Fremdschlüssel bei der einfachen Entität, also hier bei "Baum", hinzugefügt.\n             Eine einfache Entität ist die Entität, die höchstens einmal mit der jeweils anderen Entität verbunden ist.\n             In diesem Fall kann ein Baum zu höchstens einem Wald gehören.\n             Da ein Baum sich auch in keinem Wald befinden kann, muss der Fremdschlüssel optional sein.\n             Da der Fremdschlüssel auf "Wald" verweist, geht der Pfeil von "Baum" nach "Wald".`,`Es kann vorkommen, dass es einen Wald gibt, zu dem kein Baum existiert, der auf den Wald verweist und somit der Wald keine Bäume hat.\n             Das ein Wald immer mindestens einen Baum hat, lässt sich im relationalen Schema nicht darstellen und muss später in der Datenbank mit anderen Mitteln sichergestellt werden.`]},{text:"Ein Sonne kann Planeten haben, die sie umkreisen.",relationship:["Sonne","hat","Planet"],solution:["1","cn"],hints:[`Es handelt sich um eine 1:N-Beziehung, daher wird keine "hat"-Tabelle benötigt.\n             Bei einer 1:N-Beziehung wird der Fremdschlüssel bei der einfachen Entität, also hier bei "Planet", hinzugefügt.\n             Eine einfache Entität ist die Entität, die höchstens einmal mit der jeweils anderen Entität verbunden ist.\n             In diesem Fall umkreist ein Planet immer genau eine Sonne.\n             Da der Fremdschlüssel auf "Sonne" verweist, geht der Pfeil von "Planet" nach "Sonne".`,`Die NASA hat inzwischen einen Planeten entdeckt der zwei Sonnen umkreist.\n             Dies wurde in dieser Aufgabe nicht berücksichtigt.\n             Es sei aber zumindest an dieser Stelle erwähnt, falls es jemand ganz genau nimmt.`]},{text:"Ein Buch hat mehrere Seiten.",relationship:["Buch","hat","Seite"],solution:["1","n"],hints:[`Es handelt sich um eine 1:N-Beziehung, daher wird keine "hat"-Tabelle benötigt.\n             Bei einer 1:N-Beziehung wird der Fremdschlüssel bei der einfachen Entität, also hier bei "Seite", hinzugefügt.\n             Eine einfache Entität ist die Entität, die höchstens einmal mit der jeweils anderen Entität verbunden ist.\n             In diesem Fall gehört eine Seite immer genau zu einem Buch.\n             Da der Fremdschlüssel auf "Buch" verweist, geht der Pfeil von "Seite" nach "Buch".`,`Es kann vorkommen, dass es ein Buch gibt, zu dem keine Seite existiert, die auf das Buch verweist und somit das Buch keine Seiten hat.\n             Das ein Buch immer mindestens eine Seite hat, lässt sich im relationalen Schema nicht darstellen und muss später in der Datenbank mit anderen Mitteln sichergestellt werden.`]},{text:"Kunden kaufen Produkte.",relationship:["Kunde","hat gekauft","Produkt"],solution:["cn","cn"],hints:[`Es handelt sich um eine N:M-Beziehung, daher muss eine "hat gekauft"-Tabelle angelegt werden, um die N:M-Beziehung in zwei 1:N-Beziehungen zu überführen.\n             Dieser Tabelle muss dann je ein Fremdschlüssel für jede der beiden Entitäten "Kunde" und "Produkt" hinzugefügt werden.\n             Damit jede Kombination aus "Kunde" und "Produkt" nur einmal vorkommen kann, müssen die beiden Fremdschlüssel einen zusammengesetzten Alternativschlüssel bilden.\n             Da die beiden Fremdschlüssel der mittleren "hat gekauft"-Tabelle auf die beiden äußeren Tabellen "Kunde" und "Produkt" verweisen, gehen die Pfeile von der mittleren Tabelle zu den äußeren Tabellen.`,""]},{text:"Auf einem Rezept stehen Zutaten.",relationship:["Rezept","hat","Zutat"],solution:["cn","n"],hints:[`Es handelt sich um eine N:M-Beziehung, daher muss eine "hat"-Tabelle angelegt werden, um die N:M-Beziehung in zwei 1:N-Beziehungen zu überführen.\n             Dieser Tabelle muss dann je ein Fremdschlüssel für jede der beiden Entitäten "Rezept" und "Zutat" hinzugefügt werden.\n             Damit jede Kombination aus "Rezept" und "Zutat" nur einmal vorkommen kann, müssen die beiden Fremdschlüssel einen zusammengesetzten Alternativschlüssel bilden.\n             Da die beiden Fremdschlüssel der mittleren "hat"-Tabelle auf die beiden äußeren Tabellen "Rezept" und "Zutat" verweisen, gehen die Pfeile von der mittleren Tabelle zu den äußeren Tabellen.`,`Es ist möglich, dass es zu einem Rezept keine Zutat gibt, die auf das Rezept verweist und somit ein Rezept keine Zutaten hat.\n             Das ein Rezept immer mindestens eine Zutat hat, lässt sich im relationalen Schema nicht darstellen und muss später in der Datenbank mit anderen Mitteln sichergestellt werden.`]},{text:"Ein Haus hat Eigentümer und Eigentümer haben Häuser.",relationship:["Haus","hat","Eigentümer"],solution:["n","n"],hints:[`Es handelt sich um eine N:M-Beziehung, daher muss eine "hat"-Tabelle angelegt werden, um die N:M-Beziehung in zwei 1:N-Beziehungen zu überführen.\n             Dieser Tabelle muss dann je ein Fremdschlüssel für jede der beiden Entitäten "Haus" und "Eingentümer" hinzugefügt werden.\n             Damit jede Kombination aus "Haus" und "Eingentümer" nur einmal vorkommen kann, müssen die beiden Fremdschlüssel einen zusammengesetzten Alternativschlüssel bilden.\n             Da die beiden Fremdschlüssel der mittleren "hat"-Tabelle auf die äußeren beiden Tabellen "Rezept" und "Zutat" verweisen, gehen die Pfeile von der mittleren Tabelle zu den äußeren Tabellen.`,`Es ist möglich, dass es zu einem Haus keinen Eigentümer gibt, der auf das Haus verweist und somit ein Haus keinen Eigentümer hat.\n             Umgekehrt kann es auch vorkommen, dass es einen Eigentümer gibt, zu dem es kein Haus gibt, das auf den Eigentümer verweist und somit ein Eigentümer kein Haus hat.\n             Das ein Haus immer mindestens einen Eigentümer hat und ein Eigentümer immer mindestens ein Haus hat, lässt sich im relationalen Schema nicht darstellen und muss später in der Datenbank mit anderen Mitteln sichergestellt werden.`]}],show_solution:true,shuffle:true,text:{cancel:"Abbrechen",correct:"Ihre Antwort war richtig!",correct_solution:"Richtige Lösung:",current_state:"Sie haben %% von %% Aufgaben richtig beantwortet!",entity1:"Entity 1",entity2:"Entity 2",failed:"Ihre letzte Antwort war falsch!",finish:"Neustart",heading:"Lösen Sie die gezeigte Beziehung zwischen den beiden Entitäten auf!",notation:"ER-Notation:",legend:"Legende",next:"Weiter",phrase:"Phrase [%%]:",selection:["Bitte auswählen","einfach","bedingt","mehrfach","bedingt mehrfach"],show_feedback:"Zeige Feedback",show_solution:"Zeige Lösung",submit:"Antworten",table:"-Tabelle",title:"ER-zu-relationales-Schema-Trainer"},values:["1","c","n","cn"]},Instance:function(){let $,dataset,notation,phrase_nr,phrases;this.init=(async()=>{$=Object.assign({},this.ccm.helper,this.helper);$.use(this.ccm);this.modal.legend.title=this.text.legend;this.modal.attr.title="Neuer Fremdschlüssel";for(const key in this.notations){let notation=this.notations[key];this.notations[key]={key:notation.key,title:notation.title,swap:!!notation.swap,centered:!!notation.centered,left:notation.left||this.default.left,images:(notation.images||this.default.images).map(image=>image.includes(".")?image:(notation.path||this.default.path)+notation.key+"/"+image+"."+(notation.format||this.default.format)),comment:notation.comment}}if($.isObject(this.phrases))this.phrases=Object.values(this.phrases);this.phrases=this.phrases.filter(phrase=>{delete phrase.key;return phrase.relationship[0]!==phrase.relationship[2]})});this.ready=(async()=>{phrases=$.clone(this.phrases);this.shuffle&&$.shuffleArray(phrases);if(!this.number)this.number=phrases.length;this.logger&&this.logger.log("ready",$.privatize(this,true))});this.start=(async()=>{if(phrases.length<this.number){phrases=$.clone(this.phrases);this.shuffle&&$.shuffleArray(phrases)}dataset=await $.dataset(this.data);dataset=Object.assign(dataset,{correct:0,notation:notation||dataset.notation||this.default.notation,sections:[],total:this.number});phrase_nr=0;nextPhrase();this.html.render(this.html.legend(this),this.modal.legend.element.querySelector("main"));this.logger&&this.logger.log("start",{dataset:$.clone(dataset),phrases:$.clone(phrases)})});this.getValue=(()=>$.clone(dataset));const nextPhrase=()=>{phrase_nr++;dataset.sections.push({input:{keys:[null,null,null],arrows:[[false,false,false],[false,false,false],[false,false,false]]},relationship:phrases[0].relationship,solution:phrases[0].solution,text:phrases[0].text});render()};const render=()=>{this.html.render(this.html.main(this,dataset,phrases[0],phrase_nr,events),this.element);this.element.querySelectorAll("[selected]").forEach(option=>option.selected=true)};const events={onNotationChange:event=>{dataset.notation=notation=event.target.value;render()},onLegendClick:()=>this.modal.legend.open(),onAddTable:table=>{dataset.sections[phrase_nr-1].input.keys[table]=[null,null,null];render()},onRemoveTable:table=>{const keys=dataset.sections[phrase_nr-1].input.keys;keys[table]=null;keys.forEach(fks=>fks&&(fks[table]=null));render()},onAddAttr:table=>{const section=dataset.sections[phrase_nr-1];const modal=this.modal.attr;const onSubmit=event=>{event.preventDefault();const fk=$.formData(modal.element.querySelector("form"));section.input.keys[table][fk.table]={opt:fk.opt,ak:fk.ak};render();modal.close()};this.html.render(this.html.fkForm(section,table,onSubmit),modal.element.querySelector("main"));modal.element.querySelectorAll('input[type="checkbox"]').forEach(checkbox=>checkbox.checked=false);modal.open()},onRemoveAttr:(from,to)=>{dataset.sections[phrase_nr-1].input.keys[from][to]=null;render()},onArrowChange:event=>{dataset.sections[phrase_nr-1].input.arrows[event.target.dataset.from][event.target.dataset.to]=!!parseInt(event.target.value);render()},onCancelButton:()=>this.oncancel&&this.oncancel(this,phrase_nr),onSubmitButton:()=>{const section=dataset.sections[phrase_nr-1];const left=section.solution[0];const right=section.solution[1];const single_left=left==="c"||left==="1";const single_right=right==="c"||right==="1";const multi=(left==="cn"||left==="n")&&(right==="cn"||right==="n");section.feedback={keys:[[null,null,(!single_left||!(left==="1"&&right==="c"))&&single_right?{opt:right==="c",ak:single_left&&single_right&&!(left==="c"&&right==="c")}:null],multi?[{opt:false,ak:true},null,{opt:false,ak:true}]:null,[single_left&&(!single_right||left==="1"&&right==="c")?{opt:left==="c",ak:single_left&&single_right}:null,null,null]],arrows:[[false,false,(!single_left||!(left==="1"&&right==="c"))&&single_right],[multi,false,multi],[single_left&&(!single_right||left==="1"&&right==="c"),false,false]]};section.correct=JSON.stringify(section.input)===JSON.stringify(section.feedback);section.correct&&dataset.correct++;this.feedback&&this.element.classList.add(section.correct?"correct":"failed");render();!this.feedback&&events.onNextButton()},onSolutionButton:()=>{const feedback=dataset.sections[phrase_nr-1].feedback;feedback.show_solution=!feedback.show_solution;render()},onNextButton:()=>{const section=dataset.sections[phrase_nr-1];delete section.feedback.show_solution;section.solution=section.feedback;delete section.feedback;this.element.classList.remove("correct");this.element.classList.remove("failed");phrases.shift();nextPhrase();this.logger&&this.logger.log("next",{nr:phrase_nr,phrase:$.clone(phrases[0])})},onFinishButton:()=>{const section=dataset.sections[phrase_nr-1];delete section.feedback.show_solution;section.solution=section.feedback;delete section.feedback;this.element.classList.remove("correct");this.element.classList.remove("failed");phrases.shift();this.onfinish&&$.onFinish(this);this.logger&&this.logger.log("finish",this.getValue())}}}};let b="ccm."+component.name+(component.version?"-"+component.version.join("."):"")+".js";if(window.ccm&&null===window.ccm.files[b])return window.ccm.files[b]=component;(b=window.ccm&&window.ccm.components[component.name])&&b.ccm&&(component.ccm=b.ccm);"string"===typeof component.ccm&&(component.ccm={url:component.ccm});let c=(component.ccm.url.match(/(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)/)||[""])[0];if(window.ccm&&window.ccm[c])window.ccm[c].component(component);else{var a=document.createElement("script");document.head.appendChild(a);component.ccm.integrity&&a.setAttribute("integrity",component.ccm.integrity);component.ccm.crossorigin&&a.setAttribute("crossorigin",component.ccm.crossorigin);a.onload=function(){(c="latest"?window.ccm:window.ccm[c]).component(component);document.head.removeChild(a)};a.src=component.ccm.url}})();